/* Main.c generated by valac 0.56.13, the Vala compiler
 * generated from Main.vala, do not modify */

#include <gtk/gtk.h>
#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <clutter-gtk/clutter-gtk.h>
#include <gst/gst.h>
#include <gdk/gdk.h>
#include <clutter/clutter.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW (komorebi_on_screen_background_window_get_type ())
#define KOMOREBI_ON_SCREEN_BACKGROUND_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW, KomorebiOnScreenBackgroundWindow))
#define KOMOREBI_ON_SCREEN_BACKGROUND_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW, KomorebiOnScreenBackgroundWindowClass))
#define KOMOREBI_ON_SCREEN_IS_BACKGROUND_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW))
#define KOMOREBI_ON_SCREEN_IS_BACKGROUND_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW))
#define KOMOREBI_ON_SCREEN_BACKGROUND_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), KOMOREBI_ON_SCREEN_TYPE_BACKGROUND_WINDOW, KomorebiOnScreenBackgroundWindowClass))

typedef struct _KomorebiOnScreenBackgroundWindow KomorebiOnScreenBackgroundWindow;
typedef struct _KomorebiOnScreenBackgroundWindowClass KomorebiOnScreenBackgroundWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

VALA_EXTERN KomorebiOnScreenBackgroundWindow** komorebi_backgroundWindows;
VALA_EXTERN gint komorebi_backgroundWindows_length1;
KomorebiOnScreenBackgroundWindow** komorebi_backgroundWindows = NULL;
gint komorebi_backgroundWindows_length1 = 0;
static gint _komorebi_backgroundWindows_size_ = 0;
VALA_EXTERN gint komorebi_monitorCount;
gint komorebi_monitorCount = 0;
VALA_EXTERN gint komorebi_targetMonitor;
gint komorebi_targetMonitor = 0;

VALA_EXTERN GType komorebi_on_screen_background_window_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (KomorebiOnScreenBackgroundWindow, g_object_unref)
static void komorebi_main (gchar** args,
                    gint args_length1);
VALA_EXTERN void komorebi_utilities_readConfigurationFile (gint monitorNumber);
VALA_EXTERN void komorebi_utilities_readWallpaperFile (void);
VALA_EXTERN KomorebiOnScreenBackgroundWindow* komorebi_on_screen_background_window_new (gint monitorIndex);
VALA_EXTERN KomorebiOnScreenBackgroundWindow* komorebi_on_screen_background_window_construct (GType object_type,
                                                                                  gint monitorIndex);
VALA_EXTERN void komorebi_on_screen_background_window_fadeIn (KomorebiOnScreenBackgroundWindow* self);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
komorebi_main (gchar** args,
               gint args_length1)
{
	GtkSettings* _tmp1_;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp2_;
	GdkScreen* _tmp3_;
	GdkScreen* _tmp4_;
	KomorebiOnScreenBackgroundWindow** _tmp5_;
	GtkSettings* mainSettings = NULL;
	GtkSettings* _tmp10_;
	GtkSettings* _tmp11_;
	GtkSettings* _tmp12_;
	GtkSettings* _tmp13_;
	GtkSettings* _tmp14_;
	g_print ("Welcome to Komorebi\n");
	if (args_length1 > 1) {
		const gchar* _tmp0_;
		_tmp0_ = args[1];
		komorebi_targetMonitor = atoi (_tmp0_);
		if (komorebi_targetMonitor < 0) {
			g_print ("[ERROR]: Invalid monitor number. Program will run on the first monitor" \
".\n");
			komorebi_targetMonitor = 0;
		}
	}
	gtk_clutter_init ((gint*) (&args_length1), &args);
	gtk_init ((gint*) (&args_length1), &args);
	komorebi_utilities_readConfigurationFile (komorebi_targetMonitor);
	gst_init ((gint*) (&args_length1), &args);
	_tmp1_ = gtk_settings_get_default ();
	g_object_set (_tmp1_, "gtk-application-prefer-dark-theme", TRUE, NULL);
	_tmp2_ = gdk_screen_get_default ();
	_tmp3_ = _g_object_ref0 (_tmp2_);
	screen = _tmp3_;
	_tmp4_ = screen;
	komorebi_monitorCount = gdk_screen_get_n_monitors (_tmp4_);
	if (komorebi_targetMonitor >= komorebi_monitorCount) {
		g_print ("[ERROR]: Monitor number exceeds number of available monitors. Program " \
"will run on the first monitor.\n");
		komorebi_targetMonitor = komorebi_monitorCount - 1;
	}
	komorebi_utilities_readWallpaperFile ();
	_tmp5_ = g_new0 (KomorebiOnScreenBackgroundWindow*, komorebi_monitorCount + 1);
	komorebi_backgroundWindows = (_vala_array_free (komorebi_backgroundWindows, komorebi_backgroundWindows_length1, (GDestroyNotify) g_object_unref), NULL);
	komorebi_backgroundWindows = _tmp5_;
	komorebi_backgroundWindows_length1 = komorebi_monitorCount;
	_komorebi_backgroundWindows_size_ = komorebi_backgroundWindows_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				if (!_tmp6_) {
					gint _tmp7_;
					i = i + 1;
					_tmp7_ = i;
				}
				_tmp6_ = FALSE;
				if (!(i < komorebi_monitorCount)) {
					break;
				}
				if (i == komorebi_targetMonitor) {
					KomorebiOnScreenBackgroundWindow** _tmp8_;
					gint _tmp8__length1;
					KomorebiOnScreenBackgroundWindow* _tmp9_;
					_tmp8_ = komorebi_backgroundWindows;
					_tmp8__length1 = komorebi_backgroundWindows_length1;
					_tmp9_ = komorebi_on_screen_background_window_new (i);
					g_object_ref_sink (_tmp9_);
					_g_object_unref0 (_tmp8_[i]);
					_tmp8_[i] = _tmp9_;
				}
			}
		}
	}
	_tmp10_ = gtk_settings_get_default ();
	_tmp11_ = _g_object_ref0 (_tmp10_);
	mainSettings = _tmp11_;
	_tmp12_ = mainSettings;
	g_object_set ((GObject*) _tmp12_, "gtk-xft-antialias", 1, NULL, NULL);
	_tmp13_ = mainSettings;
	g_object_set ((GObject*) _tmp13_, "gtk-xft-rgba", "none", NULL, NULL);
	_tmp14_ = mainSettings;
	g_object_set ((GObject*) _tmp14_, "gtk-xft-hintstyle", "slight", NULL, NULL);
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp15_ = FALSE;
			_tmp15_ = TRUE;
			while (TRUE) {
				if (!_tmp15_) {
					gint _tmp16_;
					i = i + 1;
					_tmp16_ = i;
				}
				_tmp15_ = FALSE;
				if (!(i < komorebi_monitorCount)) {
					break;
				}
				if (i == komorebi_targetMonitor) {
					KomorebiOnScreenBackgroundWindow** _tmp17_;
					gint _tmp17__length1;
					KomorebiOnScreenBackgroundWindow* _tmp18_;
					_tmp17_ = komorebi_backgroundWindows;
					_tmp17__length1 = komorebi_backgroundWindows_length1;
					_tmp18_ = _tmp17_[i];
					komorebi_on_screen_background_window_fadeIn (_tmp18_);
				}
			}
		}
	}
	clutter_main ();
	_g_object_unref0 (mainSettings);
	_g_object_unref0 (screen);
}

int
main (int argc,
      char ** argv)
{
	komorebi_main (argv, argc);
	return 0;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

